%% =========================== cgR-SPLINE =================================
%
% *** DATE
%        Last updated March, 2014
%
% *** AUTHOR
%        Kalyani Nagaraj
%        Virginia Tech, Blacksburg, VA 
%        kalyanin AT vt DOT edu
%
%==========================================================================

function [Awork, Abest, AbestF, AbestFVar, AbestGrad, AbestGradCov, ...
    Acurrprobseed, solvseed, other] = cgRSPLINE(x, problem, param, probseed,...
    problemseedparamm, sparam, solvseed, solverseedparam, budg, logfilename)
global AirportSecurityFlag
global mobs
global log_test
AirportSecurityFlag = 1;
mobs = 0;
%==========================================================================
% INPUT
%       x=[xmin; xmax]
%         range of X
%       problem
%         problem name 
%       param
%         vector of problem parameters 
%       probseed
%         vector of input seeds to oracle
%       sparam 
%          sparam(1): numfinalsols
%          sparam(2): numrestarts
%          sparam(3): kmax 
%          sparam(4): q 
%          sparam(5): delta 
%          sparam(6): c1 
%          sparam(7): c2
%          sparam(8): biasthreshold
%          sparam(9): cvthreshold
%          sparam(10): yesgeom
%          sparam(11): constant, a
%          sparam(12): base, c
%          sparam(13): restart budget constant, a
%          sparam(14): restart budget exponent,c (polynomial growth, a*r^c)
%          sparam(15): alpha (alpha_r = alpha*(1-c^(r+1)))
%          sparam(16): c (alpha_r = alpha*(1-c^(r+1)))
%       logfilename
%          solver log file
%       solvseed
%          solvseed(1): seed to each restart loop
%       budg
%          total budget across all outer iterations 
%
% OUTPUT
%        Awork
%              Total number of calls made to the oracle. 
%        Abest
%              An array of size = 'numfinalsols' X 'dim' X 'maxsolsetsize' 
%              of solutions returned by solver.
%              Note that integer variable 'maxsolsetsize' is generated by 
%              the solver. It denotes the maximum number of estimated best 
%              solutions returned after budget(1), budget(2), ..., 
%              budget(numfinalsols) number of calls to the oracle.
%        AbestF 
%              A matrix of size 'numfinalsols' X ('nprimMeas'+'nsecMeas') X
%              'maxsolsetsize' of performance measure estimates.
%              fn = [g1, g2, ..., g_nprimMeas, h1, h2, ..., h_nsecMeas]
%              g1, g2, ..., g_nprimMeas are primary (or objective) function 
%              estimates. 
%              h1, h2, ..., h_nsecMeas are secondary (or constraint)
%              function estimates. 
%              Reals.
%        AbestFVar
%              Array of covariance estimators of Fn.
%              Reals. 
%        AbestGrad     
%              Gradient estimate of the true perfomance measures at x
%              Will typically be a matrix of size 
%              ('nprimMeas'+'nsecMeas') X 'dim',
%              unless 'numfinalsols' > 1, or maxsolsetsize > 1, or both.
%              Reals.
%        AbestGradCov
%              Array of covariance estimators of Grad. 
%              Reals.
%        Acurrprobseed     
%              Output problem seed(s).
%        solvseed     
%              Output solver seed(s).
%        other
%              Placeholder variable. Currently unused.

%==========================================================================
% REFERENCES
%     [1] K. Nagaraj and R. Pasupathy
%     Stochastically Constrained Simulation Optimization On Interger-
%     Ordered Spaces: The cgR-SPLINE Algorithm, 2015, Under review with 
%     Operations Research.
%
%     [2] H. Wang, R. Pasupathy, and B. Schmeiser,
%     Integer-Ordered Simulation Optimization using R-SPLINE: 
%     Retrospective Search with Piecewise-Linear Interpolation and
%     Neighborhood Enumeration, ACM TOMACS, 2012
%==========================================================================

xmin=x(1,:);
xmax=x(2,:);
other=NaN;

logfilename=strcat(logfilename, '.txt');
logfid=fopen(logfilename, 'w'); 

% Solver parameters
numrestarts=sparam(2); 
delta=sparam(5);

% Problem parameters
id=int32(param(2));
nseeds=int32(param(3));
nsecMeas=int32(param(4));

% Declare o/p data structures
Awork=zeros(numrestarts, 1);
Amk=zeros(numrestarts, 1);

% Solution from current call to R-SPLINE
Acurr=zeros(numrestarts, id);
Acurrfn=zeros(numrestarts, 1);
AcurrFnVar=zeros(numrestarts, 1);
Acurrconstraint=zeros(numrestarts, nsecMeas);
AcurrConstraintCov=zeros(numrestarts, nsecMeas);
Acurrprobseed=zeros(numrestarts, nseeds);
Acurrphat = zeros(numrestarts, 1);

%Incumbent Solution
Ainc=zeros(numrestarts, id);
Aincfn=zeros(numrestarts, 1);
AincFnVar=zeros(numrestarts, 1);
Aincconstraint=zeros(numrestarts, nsecMeas);
AincConstraintCov=zeros(numrestarts, nsecMeas);
Aincphat = zeros(numrestarts, 1);

%Current best after comparison with incumbent
Abest=zeros(numrestarts, id);
Abestfn=zeros(numrestarts, 1);
AbestFnVar=zeros(numrestarts, 1);
Abestconstraint=zeros(numrestarts, nsecMeas);
AbestConstraintCov=zeros(numrestarts, nsecMeas);
Abestphat = zeros(numrestarts, 1);
AbestGrad=NaN;
AbestGradCov=NaN;

bmax=budg;
totalcalls=0;
starttime=clock;
r=1;

global SecurityLevel_Global
global Constraints_Global
global RefMatrixSize
global StartificationFlag

global x_set
x_set = [];
RefMatrixSize = xmax;

Test_x0_record = [];
Test_SL_record = [];
Test_Constraint_record = [];
Test_initial_point = [];
while 1
        
    while 1
        %[x0,solvseed]=GenInput(solvseed, xmin, xmax);
		if StartificationFlag == 0
			[x0,solvseed]=GenInput_AirportSecurity(solvseed, xmin, xmax);
		else
			[x0,solvseed]=GenInput_DynamicStartification(solvseed, xmin, xmax);
		end
			
        if x0(1)+x0(2) <= 0
            continue
        end
        
        Test_initial_point = [Test_initial_point; x0];
        
        budgr=ceil(sparam(13)*sparam(14)^r);
        alphar=sparam(15)*(1-sparam(16)^(1+r));
        
        disp(['OuterIter:'   num2str(r) ',startpoint:' num2str(x0(1))   ',' num2str(x0(2)) ])
        disp(['OuterIter:'   num2str(r) ',budgr:' num2str(budgr) ])
        
        [ncalls, x1, x1fn, x1FnVar, x1constraint, x1ConstraintCov, FO, ...
            probseed, k, lastiseed] = RSPLINE(x0, problem, param, ...
            probseed, sparam, logfid, budgr, alphar);
        break;
        if ~isnan(x1fn)
            %break;
        end
    end
    % k is the last retrospective iteration number in the call to R-SPLINE,
    % lastiseed is the input to the kth RSPLINE iteration, needed to update
    % ghat and fhat for backfill
    Test_x0_record = [Test_x0_record; x0]; %BG_Modified
    Test_SL_record = [Test_SL_record; SecurityLevel_Global]; %BG_Modified
    Test_Constraint_record = [Test_Constraint_record; Constraints_Global]; %BG_Modified
    %Update A matrices for the current solution
    Acurr(r,:)=x1;
    Acurrfn(r,1)=x1fn;
    AcurrFnVar(r,1)=x1FnVar;
    Acurrconstraint(r,:)=x1constraint;
    AcurrConstraintCov(r,:)=x1ConstraintCov;
    Acurrprobseed(r,:)=probseed;
  
    totalcalls = totalcalls + ncalls;
    fprintf(log_test,'Totalcalls = %d\n',totalcalls);
    disp(['OuterIter:'   num2str(r) ',totalcalls:' num2str(totalcalls) ])
    disp(['OuterIter:'   num2str(r) ',endpoint:' num2str(x1(1)) ',' num2str(x1(2)) ])
    disp(['OuterIter:'   num2str(r) ',seed:' num2str(probseed(1)) ',' num2str(probseed(2))  ',' num2str(probseed(3))  ])
    Awork(r,1)=totalcalls;
    
    % calculate mk 
    if sparam(10)==1
        mk=ceil(sparam(11)*sparam(12)^k);
    else
        mk=sparam(6)*ceil(k^sparam(4));
    end
    Amk(r,1)=mk;
    Acurrphat(r,1)=tcdf(Amk(r,1)^(0.5-sparam(5))-...
        x1constraint/sqrt(x1ConstraintCov), Amk(r,1)-1); 

    if r==1
        AcurrFO=FO;
        AincFO='NA'; %Not Applicable
        
        xbest = x1;
        xbestfn = x1fn;
        xbestFnVar = x1FnVar;
        xbestconstraint = x1constraint;
        xbestConstraintCov = x1ConstraintCov;
        xbestFO=FO;
        
        Abest(r,:)=x1;
        Abestfn(r,1)=x1fn;
        AbestFnVar(r,1)=x1FnVar;
        Abestconstraint(r,:)=x1constraint;
        AbestConstraintCov(r,:)=x1ConstraintCov;
        Abestphat(r,1)=Acurrphat(r,1); 
        AbestFO=FO;
        
        mkprev = mk;% BG modification
        if isnan(x1fn) 
            disp('')
        end
        
        if strcmp(xbestFO, '-')==0 
            %returned a sample path feasible solution
            prevlastiseed=lastiseed;
        end

    else %r>1
        AcurrFO=char(AcurrFO, FO);
        
        Ainc(r,:)=Abest(r-1,:);
        Aincfn(r,1)=Abestfn(r-1,1);
        AincFnVar(r,1)=AbestFnVar(r-1,1);
        Aincconstraint(r,:)=Abestconstraint(r-1,:);
        AincConstraintCov(r,:)=AbestConstraintCov(r-1,:);
        Aincphat(r,1)=Abestphat(r-1,1); 
        AincFO=char(AincFO, AbestFO(r-1,:));
        
        if strcmp(FO, '-')==1 && strcmp(xbestFO, '-')==1 
            % No sample path feasible sol obtained so far
            AbestFO=char(AbestFO, FO);
            
        elseif strcmp(FO, '-')==1 && strcmp(xbestFO, '-')==0 
            % Current restart did not return a deemed feas sol.
            % Check if incumbent solution is at current level alpha_r
            % In not then if ncalls <= budgr then check neighbors and 
            % possibly move in direction of interior of feasible region 
            % to achieve level alpha_r feasibility
            if ncalls<budgr && Aincphat(r,1)<alphar
                [Dummy, xnew, xnewfn, xnewFnVar, xnewconstraint, ...
                    xnewConstraintCov, xnewphat, xnewFO, probseed] = ...
                    backtrackRR(problem, param, sparam, xmin, xmax, ...
                    xbest, xbestfn, xbestFnVar, xbestconstraint, ...
                    xbestConstraintCov, mkprev, probseed, delta, ...
                    budgr-ncalls, alphar);
                if isequal(xnew, xbest)== 0
                    xbest=xnew;
                    xbestfn=xnewfn;
                    xbestFnVar=xnewFnVar;
                    xbestconstraint=xnewconstraint;
                    xbestConstraintCov=xnewConstraintCov;
                    xbestFO=xnewFO;

                    Ainc(r,:)=xnew;
                    Aincfn(r,1)=xnewfn;
                    AincFnVar(r,1)=xnewFnVar;
                    Aincconstraint(r,:)=xnewconstraint;
                    AincConstraintCov(r,:)=xnewConstraintCov;
                    AincFO(r,:)=xnewFO;
                    Aincphat(r,1)=xnewphat;    
                end
            end
            
            Abest(r,:)=Ainc(r,:);
            Abestfn(r,1)=Aincfn(r,1);
            AbestFnVar(r,1)=AincFnVar(r,1);
            Abestconstraint(r,:)=Aincconstraint(r,:);
            AbestConstraintCov(r,:)=AincConstraintCov(r,:);
            Abestphat(r,1)=Aincphat(r,1);
            AbestFO=char(AbestFO, AincFO(r,:));
            
            if isnan(Abestfn(r,1))
                disp('')
            end

        elseif strcmp(FO, '-')==0 && strcmp(xbestFO, '-')==1 
            % First time restart yielded in a deemed feas sol.
            % Update xbest without comparing. 
            xbest = x1;
            xbestfn = x1fn;
            xbestFnVar = x1FnVar;
            xbestconstraint = x1constraint;
            xbestConstraintCov = x1ConstraintCov;
            xbestFO=FO;
            prevlastiseed=lastiseed;
            
            Abest(r,:)=x1;
            Abestfn(r,1)=x1fn;
            AbestFnVar(r,1)=x1FnVar;
            Abestconstraint(r,:)=x1constraint;
            AbestConstraintCov(r,:)=x1ConstraintCov;
            Abestphat(r,1)=Acurrphat(r,1); 
            AbestFO=char(AbestFO, FO);
            
            if isnan(x1)
                disp('')
            end
            mkprev = mk;% BG modification
           
        else
            xbestFk=1; % initialize as sample path feasible
            x1Fk=1;    % initialize as sample path feasible

            % Get mk to backfill
            if mk~=mkprev
                mkdiff=abs(mk-mkprev);
                mkdiffnew = mkdiff; %Modified by BG
                %mkdiffnew=min(mkdiff, 1000 - rem(totalcalls, 1000));
                                % sol reported in step sizes of 1000
                Awork(r,1) = Awork(r,1) + mkdiffnew;
                totalcalls = totalcalls + mkdiffnew; %Bigghost Modified
                Amk(r,1)=Amk(r,1)+ mkdiffnew;
            end
            
            % Update xbest if current iteration number is higher and mk 
            % available for backfill
            if mk>mkprev && mkdiffnew>0
                fprintf(log_test,'(mkdiffnew oracle)(mk>mkprev && mkdiffnew>0)\n');
                [Dummy, Dummy, xbestfnnew, xbestFnVarnew, Dummy, Dummy, ...
                    xbestconstraintnew, xbestConstraintCovnew, Dummy, Dummy, ...
                    Dummy] = oracle(str2func(problem), param, ...
                    xbest, mkdiffnew, lastiseed);
                
                if AirportSecurityFlag == 1;
                    totalcalls = totalcalls + mobs;
                else
                    totalcalls = totalcalls + mkdiffnew;
                end
                fprintf(log_test,'(mkdiffnew oracle)(mk = %d)\n', mk);
                fprintf(log_test,'(mkdiffnew oracle)(mkprev = %d)\n', mkprev);
                xbestfn = (xbestfnnew*mkdiffnew+xbestfn*mkprev)/(mkdiffnew+mkprev);
                xbestconstraint=(xbestconstraint*mkdiffnew+xbestconstraintnew*mkprev)/(mkdiffnew+mkprev);
%                 xbestFnVar=(xbestFnVar+xbestFnVarnew)/4;
%                 xbestConstraintCov=(xbestConstraintCov+...
%                     xbestConstraintCovnew)/4;
                if sum(xbestconstraint > ...
                        sqrt((mkdiffnew+mkprev)*xbestConstraintCov)/...
                        (mkdiffnew+mkprev)^sparam(5))>0
                    xbestFk=0; % incumbent is sample path infeasible 
                end
                mkprev=mkprev+mkdiffnew;
                xbestphat=tcdf(Amk(r,1)^(0.5-sparam(5))-xbestconstraint/...
                    sqrt(xbestConstraintCov), Amk(r,1)-1); 

                Aincfn(r,1)=xbestfn;
                AincFnVar(r,1)=xbestFnVar;
                Aincconstraint(r,:)=xbestconstraint;
                AincConstraintCov(r,:)=xbestConstraintCov;
                Aincphat(r,1)=xbestphat; 
                
                if isnan(xbestfn)
                    disp('')
                end
            end
            
            % Update x1 if current iteration number is lower and 
            % mk available for backfill
            if mk<mkprev && mkdiffnew>0
                fprintf(log_test,'(mkdiffnew oracle)(mk<mkprev && mkdiffnew>0)\n');
                [Dummy, Dummy, x1fnnew, x1FnVarnew, Dummy, Dummy, x1constraintnew, ...
                    x1ConstraintCovnew, Dummy, Dummy, Dummy] = ...
                    oracle(str2func(problem), param, x1, mkdiffnew, ...
                    prevlastiseed);
                x1fn = (x1fnnew*mkdiffnew+x1fn*mkprev)/(mkdiffnew+mkprev);
                x1constraint=(x1constraint*mkprev+x1constraintnew*mkdiffnew)/(mkdiffnew+mkprev);
%                 x1FnVar=(x1FnVar+x1FnVarnew)/4;
%                 x1ConstraintCov=(x1ConstraintCov+x1ConstraintCovnew)/4;
                if AirportSecurityFlag == 1;
                    totalcalls = totalcalls + mobs;
                else
                    totalcalls = totalcalls + mkdiffnew;
                end
                if sum(x1constraint > sqrt((mk+mkdiffnew)*...
                        x1ConstraintCov)/(mk+mkdiffnew)^sparam(5))>0
                    x1Fk=0; % competitor is sample path infeasible
                end
                mk=mk+mkdiffnew;
                x1phat=tcdf(Amk(r,1)^(0.5-sparam(5))-x1constraint/...
                    sqrt(x1ConstraintCov), Amk(r,1)-1); 
               
                Acurrfn(r,1)=x1fn;
                AcurrFnVar(r,1)=x1FnVar;
                Acurrconstraint(r,:)=x1constraint;
                AcurrConstraintCov(r,:)=x1ConstraintCov;
                Acurrphat(r,1)=x1phat; 
            end

            if (x1fn < xbestfn && xbestFk==1 && ...
                    x1Fk==1 && Acurrphat(r,1)>=alphar && ...
                    Aincphat(r,1)>=alphar) ...
                    || (xbestFk==0 && x1Fk==1) ...
                    || (x1fn==xbestfn && xbestFk==1 && x1Fk==1 && ...
                    Acurrphat(r,1)>=alphar && Aincphat(r,1)>=alphar && ...
                        ((x1constraint <= 0 && xbestconstraint>0)...
                        ||(x1constraint>0 && ...
                           bestconstraint>x1constraint))) ...
                    ||(xbestFk==1 && x1Fk==1 && Acurrphat(r,1)>=alphar ...
                    && Aincphat(r,1)<alphar) ...
                    || (xbestFk==1 && x1Fk==1 ...
                    && Aincphat(r,1)<=Acurrphat(r,1) && ...
                    Acurrphat(r,1)<alphar)
            
                xbest = x1;
                xbestfn = x1fn;
                xbestFnVar = x1FnVar;
                xbestconstraint = x1constraint;
                xbestConstraintCov = x1ConstraintCov;
                xbestFO=FO;
                
                Abest(r,:)=Acurr(r,:);
                Abestfn(r,1)=Acurrfn(r,1);
                AbestFnVar(r,1)=AcurrFnVar(r,1);
                Abestconstraint(r,:)=Acurrconstraint(r,:);
                AbestConstraintCov(r,:)=AcurrConstraintCov(r,:);
                Abestphat(r,1)=Acurrphat(r,1);
                AbestFO=char(AbestFO, FO);
                
                if isnan(Abestfn(r,1))
                    disp('')
                end
                
            else
                Abest(r,:)=Ainc(r,:);
                Abestfn(r,1)=Aincfn(r,1);
                AbestFnVar(r,1)=AincFnVar(r,1);
                Abestconstraint(r,:)=Aincconstraint(r,:);
                AbestConstraintCov(r,:)=AincConstraintCov(r,:);
                Abestphat(r,1)=Aincphat(r,1);
                AbestFO=char(AbestFO, AincFO(r,:));       
                
                if isnan(Abestfn(r,1))
                    disp('')
                end
            end
        end
    end
    
    % End restarts if total budget exceeds bmax or r exceeds numrestarts
    if totalcalls>=bmax || r>=numrestarts
       break;
    end
    r=r+1;
    
end
endtime=clock;

save(strcat(logfilename, '_outputvars.mat'), 'Acurr', 'Ainc', 'Abest', ...
    'Awork', 'Amk', 'Acurrfn', 'Abestfn', 'Aincfn', 'AcurrFnVar', ...
    'AincFnVar', 'AbestFnVar', 'Acurrconstraint', 'Aincconstraint', ...
    'Abestconstraint', 'AcurrConstraintCov', 'AincConstraintCov', ...
    'AbestConstraintCov', 'AcurrFO', 'AincFO', 'AbestFO', 'Acurrphat', ...
    'Aincphat', 'Abestphat', 'Acurrprobseed','Test_x0_record','Test_SL_record','Test_Constraint_record' , 'Test_initial_point');

AbestF    = cat(2, Abestfn,Abestconstraint);
AbestFVar = cat(2,AbestFnVar,AbestConstraintCov);
end


function [x0, seed] = GenInput(seed, xmin, xmax)
id=length(xmin);
x0=zeros(1,id);
for i=1:id
	[seed, u] = u16807d(seed);
    x0(i) = floor(xmin(i) + u*(xmax(i) - xmin(i)) + 0.5);
end
end

function [x0, seed] = GenInput_AirportSecurity(seed, xmin, xmax)
%Bigghost Modified
global Budget
global Beta1
global Beta2
global c1
global c2

id=length(xmin);
x0=zeros(1,id);
[seed, u] = u16807d(seed);
x0(1) = floor(xmin(1) + u*(xmax(1) - xmin(1)) + 0.5);
Upper = floor((Budget - Beta1 - c1*x0(1))/c2);
Lower = floor(max((Budget - Beta2 - c1*x0(1))/c2,0));
%[seed, u] = u16807d(seed);
[u, seed] = mrg32k3a(seed);
x0(2) = floor(Lower + u*(Upper - Lower) + 0.5);

% for i=1:id
% 	[seed, u] = u16807d(seed);
%     x0(i) = floor(xmin(i) + u*(xmax(i) - xmin(i)) + 0.5);
% end
end


function [ncalls, xnew, xnewfn, xnewFnVar, xnewconstraint, ...
    xnewConstraintCov, xnewphat, xnewFO, iseed] = ...
    backtrackRR(problem, param, sparam, xmin, xmax, x1, x1fn, ...
    x1FnVar, x1constraint, x1ConstraintCov, mk, iseed, delta, ...
    budgr, alphar)
global AirportSecurityFlag
global mobs
% Select neighbor with the smallest objective function and with
% phat>=alpha_r or if one is not found then move in the direction of
% feasibility till one is found.

ncalls=0;
id=int32(param(2));

% Manintain a copy of the original x
xorg=x1;
xorgfn=x1fn;
xorgFnVar=x1FnVar;
xorgconstraint=x1constraint;
xorgConstraintCov=x1ConstraintCov;

while 1 % while ncalls has not exceeded budgr 
%   1. Evaluate neighbors
    [NEalpharncalls, xnew, xnewfn, xnewFnVar, xnewconstraint, ...
    xnewConstraintCov, iseed, Dummy, Dummy, Dummy, Dummy, Nconstraint, Dummy, Dummy] = ...
    NEalphar(problem, param, x1, x1fn, x1FnVar, x1constraint, ...
    x1ConstraintCov, mk, iseed, delta, sparam, alphar); 
 
    ncalls = ncalls + NEalpharncalls;

    if isequal(xnew, x1)==0  
        % NEalphar returned a level alpha_r solution 
        % from among its neighbors.        
        break;
    end


    if ncalls >= budgr  
        % Neighbors are not level alphar but budg exceeded.
        % Original x is returned since nbd search did not yeild a deemed 
        % feas solution with level alphar estimated prob of feasiility
        % and budg was exceeded.

        xnew=xorg;
        xnewfn=xorgfn;
        xnewFnVar=xorgFnVar;
        xnewconstraint=xorgconstraint;
        xnewConstraintCov=xorgConstraintCov;       
        
        break;
    end

%   2. Compute phantom gradient of constraints
    gammah=centralDiffGrad(Nconstraint);

%   3. Estimate step size in direction of feasibility (newx = oldx +
%   hhat./grad)
    xnew = bsxfun(@min, bsxfun(@max, floor(x1 - ...
        ((ones(id, 1).*x1fn)./gammah)'), xmin), xmax);

%   4. Estimate g and h at xnew. Also compute phat.   
    fprintf(log_test,'(BacktrackRR oracle)\n');
    [Dummy, flag2, xnewfn, xnewFnVar, Dummy, Dummy, xnewconstraint, ...
        xnewConstraintCov, Dummy, Dummy, iseed] = oracle(str2func(problem), ...
        param, xnew, mk, iseed);
    if sum(xnewconstraint > sqrt(mk*xnewConstraintCov)/mk^delta)>0
        flag2=1;
    end
    if AirportSecurityFlag == 1;
        ncalls = ncalls + mobs;
    else
        ncalls = ncalls + mk;
    end
    phat=tcdf(mk^(0.5-sparam(5))-xnewconstraint/...
        sqrt(xnewConstraintCov), mk-1);

%   5. Break if newx is with phat>=alpha_r OR ncalls >= budgr
    if (phat >= alphar && flag2~=1)
        % newx has been deemed feasible and is at 
        % level alphar estimated prob of feasiility        
        break;
    end
    
    if flag2~=1 && ncalls>=budgr
        % Original curr x is returned and it does not satisfy level alphar 
        % estimated prob of feasibility.
        break;
    end
    
    if ncalls>=budgr && phat<alphar
        % Original x is returned since search did not yeild a deemed feas 
        % solution with level alphar estimated prob of feasiility.
        xnew=xorg;
        xnewfn=xorgfn;
        xnewFnVar=xorgFnVar;
        xnewconstraint=xorgconstraint;
        xnewConstraintCov=xorgConstraintCov;       
        break;
    end
    
    % Begin next loop at current x
    x1=xnew;
    x1fn=xnewfn;
    x1FnVar=xnewFnVar;
    x1constraint=xnewconstraint;
    x1ConstraintCov=xnewConstraintCov;            
end 
xnewphat=tcdf(mk^(0.5-sparam(5))-xnewconstraint/...
    sqrt(xnewConstraintCov), mk-1);    
xnewFO='F';  %Deem xnew as sample-path feasible.
end



function [ncalls, xnew, xnewfn, xnewFnVar, xnewconstraint, ...
    xnewConstraintCov, iseed, Nflag, Nx, Nfn, NFnVar, Nconstraint, ...
    NConstraintCov, Nphat] = NEalphar(problem, param, x1, x1fn, x1FnVar,...
    x1constraint, x1ConstraintCov, mk, iseed, delta, sparam, alphar)
global AirportSecurityFlag
global mobs

id = int32(param(2));
nsecMeas = int32(param(4));
iseedk = iseed;
xold=x1;

xnew=x1;
xnewfn=x1fn;
xnewFnVar=x1FnVar;
xnewconstraint=x1constraint;
xnewConstraintCov=x1ConstraintCov;

ncalls=0;

Nflag=zeros(2*id, 1);
Nx=zeros(2*id, id);
Nfn=zeros(2*id, 1);
NFnVar=zeros(2*id, 1);
Nconstraint=zeros(2*id, nsecMeas);
NConstraintCov=zeros(2*id, nsecMeas);
Nphat=zeros(2*id, 1);

for i=1:id

    xold(i)=xold(i)+1;
    iseed=iseedk;
    fprintf(log_test,'(NEalphar oracle)\n');
	[Dummy, flag2, xoldfn, xoldFnVar, Dummy, Dummy, xoldconstraint, ...
        xoldConstraintCov, Dummy, Dummy, iseed] = ...
        oracle(str2func(problem), param, xold, mk, iseed);
    if sum(xoldconstraint > sqrt(mk*xoldConstraintCov)/mk^delta)>0
        flag2=1;
    end
    Nx(2*i-1,:)=xold;
    Nflag(2*i-1)=flag2;
    Nfn(2*i-1)=xoldfn;
    NFnVar(2*i-1)=xoldFnVar;
    Nconstraint(2*i-1, :)=xoldconstraint;
    NConstraintCov(2*i-1, :)=xoldConstraintCov;
    Nphat(2*i-1)=tcdf(mk^(0.5-sparam(5))-xoldconstraint/...
        sqrt(xoldConstraintCov), mk-1);

    if flag2 == 0
        if AirportSecurityFlag == 1;
            ncalls = ncalls + mobs;
        else
            ncalls = ncalls + mk;
        end
        if Nphat(2*i-1)>=alphar
			xnew=xold;
			xnewfn=xoldfn;
			xnewFnVar=xoldFnVar;
            xnewconstraint=xoldconstraint;
            xnewConstraintCov=xoldConstraintCov;
            PUSH(xnew);
            return;
        end
    end

	xold(i)=xold(i)-2;
	iseed=iseedk;
    fprintf(log_test,'(NEalphar oracle)\n');
	[Dummy, flag2, xoldfn, xoldFnVar, Dummy, Dummy, xoldconstraint, ...
        xoldConstraintCov, Dummy, Dummy, iseed] = ...
        oracle(str2func(problem), param, xold, mk, iseed);
    if sum(xoldconstraint > sqrt(mk*xoldConstraintCov)/mk^delta)>0
        flag2=1;
    end
    Nx(2*i,:)=xold;
    Nflag(2*i)=flag2;
    Nfn(2*i)=xoldfn;
    NFnVar(2*i)=xoldFnVar;
    Nflag(2*i)=flag2;
    Nconstraint(2*i,:)=xoldconstraint;
    NConstraintCov(2*i,:)=xoldConstraintCov;
    Nphat(2*i)=tcdf(mk^(0.5-sparam(5))-xoldconstraint/...
        sqrt(xoldConstraintCov), mk-1);

    if flag2 == 0
		if AirportSecurityFlag == 1
            ncalls = ncalls + mobs;
        else
            ncalls = ncalls + mk;
        end
        if Nphat(2*i)>=alphar
			xnew=xold;
			xnewfn=xoldfn;
            xnewFnVar=xoldFnVar;
            xnewconstraint=xoldconstraint;
            xnewConstraintCov=xoldConstraintCov;
            PUSH(xnew);
            return;
        end 
    end
	xold(i)=xold(i)+1;
end
end


function gammah=centralDiffGrad(Nconstraint)
% Gradient Estimator
d=size(Nconstraint);
id=d(1)/2;
nsecMeas=d(2);
gammah = zeros(id, nsecMeas);
for i=1:id
    gammah(i,:)=(Nconstraint(2*i-1,:)-Nconstraint(2*i,:))./2;
end
end


function [ncalls, x1, x1fn, x1FnVar, x1constraint, x1ConstraintCov, FO, ...
    iseed, k, lastiseed] = RSPLINE(x0, problem, param, iseed, sparam, ...
    logfid, budg, alphar)



kmax=sparam(3);
q=sparam(4);
delta=sparam(5);
c1=sparam(6);
c2=sparam(7);
cvthresh=sparam(8);
biasthresh=sparam(9);
yesgeom=sparam(10);
geoma=sparam(11);
geomc=sparam(12);

id=int32(param(2));
nseeds=int32(param(3));
nsecMeas=int32(param(4));

global stack1;
global RefMatrix_tau
global RefMatrix_AvgWT
global RefMatrix_Se_AvgWT
global RefMatrix_SecurityLevel
global RefMatrix_Cost
global RefMatrix_mobs

global log_test

global RefMatrixSize
stack1=zeros(1,id);

fnprev=0;
ncalls=0;	% tracks the total calls made to the oracle
x1=x0;
k=1;
fprintf(log_test,'Start RSPLINE: ((S1,S2), iseed, ncalls) = ((%d, %d), (%d, %d, %d), %d)\n',x0(1), x0(2), iseed(1), iseed(2), iseed(3), ncalls);
disp(['Start RSPLINE: ((S1,S2), iseed, ncalls) = ' num2str(x0(1)) ',' num2str(x0(2)) ',' num2str(iseed(1)) ',' num2str(iseed(2)) ',' num2str(iseed(3)) ',' num2str(ncalls)])
disp(['kmax=' num2str(kmax) ])
%Begin Retrospective Iterations
while (1) 
    if yesgeom==1
        mk=ceil(geoma*geomc^k);
    else
        mk=c1*ceil(k^q);
    end
    bk=c2*ceil(k^q);
    xk=x1;
    lastiseed=iseed;
    fprintf(log_test,'\tCall SPLINE: New Sample Path\n');
    
    disp(['Call SPLINE: New Sample Path'])
    disp(['InnerIter:' num2str(k) ',mk=' num2str(mk)])
    disp(['InnerIter:' num2str(k) ',bk=' num2str(bk)])
    disp(['InnerIter:' num2str(k) ',seed:' num2str(iseed(1)) ',' num2str(iseed(2))  ',' num2str(iseed(3))  ])
    
    RefMatrix_tau = -1*ones(RefMatrixSize);
    RefMatrix_AvgWT = -1*ones(RefMatrixSize);
    RefMatrix_Se_AvgWT = -1*ones(RefMatrixSize);
    RefMatrix_SecurityLevel = -1*ones(RefMatrixSize);
    RefMatrix_Cost = -1*ones(RefMatrixSize);
    RefMatrix_mobs = -1*ones(RefMatrixSize);
    
	[splinencalls, stackflag, x1, x1fn, x1FnVar, x1constraint, ...
        x1ConstraintCov, iseed, Nflag, Nx, Nfn, NFnVar, Nconstraint, ...
        NConstraintCov, Nphat] = SPLINE(problem, param, xk, mk, bk, ...
        iseed, delta, k);	
    FO='-';
    phat=tcdf(mk^(0.5-delta)-x1constraint/sqrt(x1ConstraintCov), mk-1);
    ncalls = ncalls + splinencalls;
    
    disp(['InnerIter:' num2str(k) 'end'])
    disp(['InnerIter:' num2str(k) ',endpoint'  num2str(x1(1)) ','  num2str(x1(2)) ])
    disp(['InnerIter:' num2str(k) ',ncalls' num2str(ncalls) ])
    %splinencalls is the number of oracle calls for each call of SPLINE
    
    if stackflag == 1
        if k==1
            fprintf(logfid, 'Initial solution is infeasible!!!\n');
        else
            fprintf(logfid, 'All solutions in stack are infeasible!!!\n');
        end
		return
    end
    
    if (k>=kmax || ncalls>=budg) && phat < alphar  
        % last inner loop and alphar not attained
%         [Dummy, x1new, x1newfn, x1newFnVar, x1newconstraint, ...
%             x1newConstraintCov, Dummy] = backtrack(problem, param, ...
%             x1, x1fn, x1FnVar, x1constraint, x1ConstraintCov, mk, ...
%             lastiseed, delta, Nflag, Nx, Nfn, NFnVar, Nconstraint, ...
%             NConstraintCov, Nphat, alphar, logfid);
        [Dummy, x1new, x1newfn, x1newFnVar, x1newconstraint, ...
            x1newConstraintCov, Dummy] = backtrack(param, ...
            x1, x1fn, x1FnVar, x1constraint, x1ConstraintCov, ...
            lastiseed, Nflag, Nx, Nfn, NFnVar, Nconstraint, ...
            NConstraintCov, Nphat, alphar);
        if isequal(x1new, x1)==0
            x1=x1new;
            x1fn=x1newfn;
            x1FnVar=x1newFnVar;
            x1constraint=x1newconstraint;
            x1ConstraintCov=x1newConstraintCov;
        end
    end
        
    %Choose max among sehats of all the estimators    
    cvcurr = sqrt(x1ConstraintCov(1));  
    bias = sqrt((x1fn - fnprev)^2); % calculate bias

    %% Update delta_k+1, comment to use same delta
    epsilon=min(max(sqrt(x1ConstraintCov*mk)/mk^0.45, -x1constraint), ...
        sqrt(x1ConstraintCov*mk)/mk^0.1);
    sparam(5)=(log(sqrt(x1ConstraintCov*mk))-log(epsilon))/log(mk); %ERROR_BG
    delta=sparam(5);
     
    % Exit R-SPLINE if bias, std dev, or max iteration thresholds achieved
    %  or if total budget is exceeeded.
    % if (k>=2 && cvprev <= cvthresh && cvcurr <= cvthresh && ...
    %     bias <=biasthresh) || k>=kmax
%     if (k>=2 && cvcurr <= cvthresh && bias <= biasthresh)
%         FO='F';
%         fprintf(log_test,'End RSPLINE (BIAS): ((S1,S2), tau, ncalls) = ((%d, %d), %f, %d)\n',x1(1), x1(2), x1fn, ncalls);
%         break;
%     end
    if k>=kmax || ncalls>=budg  
        FO='F';
        fprintf(log_test,'End RSPLINE (BUDGET): ((S1,S2), tau, ncalls) = ((%d, %d), %f, %d)\n',x1(1), x1(2), x1fn, ncalls);
        break;
    end
    fnprev=x1fn;
    k=k+1;
end
end


function [ncalls, stackflag, xnew, xnewfn, xnewFnVar, xnewconstraint, ...
    xnewConstraintCov, iseed, Nflag, Nx, Nfn, NFnVar, Nconstraint, ...
    NConstraintCov, Nphat]=SPLINE(problem, param, x0, mk, bk, iseed, ...
    delta, ri)
global log_test
global AirportSecurityFlag
global mobs
global stack1;
stackflag=0;  % Set to 1 if all solutions in stack are deemed infeasible 
              % at cuurent sampling level mk, else 0.

id = int32(param(2));	
nseeds = int32(param(3));
nsecMeas = int32(param(4));

Nflag=zeros(2*id, 1);
Nx=zeros(2*id, id);
Nfn=zeros(2*id, 1);
NFnVar=zeros(2*id, 1);
Nconstraint=zeros(2*id, nsecMeas);
NConstraintCov=zeros(2*id, nsecMeas); 
Nphat=zeros(2*id, 1);

iseedk = iseed;
ncalls=0;

%check all solutions in stack if the sol from prev iteration is infeasible
xnew=x0;
count=0;
ctr=0;
[nrow,Dummy]=size(stack1);
while (1)
    iseed=iseedk;
    
    [flag1, flag2, xnewfn, xnewFnVar, Dummy, Dummy, xnewconstraint, ...
        xnewConstraintCov, Dummy, Dummy, iseed] = oracle(str2func(problem), ...
        param, xnew, mk, iseed);
    if sum(xnewconstraint > sqrt(mk*xnewConstraintCov)/mk^delta)>0
        flag2=1;
    end
    %ncalls = ncalls + mk;
    if AirportSecurityFlag == 1
        ncalls = ncalls + mobs; %mobs: Number of observations generated
    else
        ncalls = ncalls + mk;
    end
     
 
    if flag1==0 && flag2==0 
        count=count+1;
        if count==1
            fnprev=xnewfn;
            xprev=xnew;
        end
        if ri==1
            PUSH(xnew);
            break
        end
        if count==2
            if fnprev<xnewfn
                xnew=xprev;
            end
            break
        end
    end
    
    ctr=ctr+1;
    if nrow-ctr<=1   % stack is empty
        stackflag=1; % denotes that stack is empty! All visited solutions
                     % are infeasible at current sampling level mk
        return
    end
        xnew=stack1(nrow-ctr,:);
end
% x0 = xnew; %BG Modified
x0fn=xnewfn;
x0FnVar=xnewFnVar;
x0constraint=xnewconstraint;
x0ConstraintCov=xnewConstraintCov;
fprintf(log_test,'\tStart SPLINE: ((S1,S2), tau, WT - EPSILON, SE_WT, mk, iseed, ncalls) = ((%d, %d), %f, %f, %f, %d, (%d, %d, %d), %d)\n',xnew(1), xnew(2), xnewfn, xnewconstraint(1), xnewConstraintCov(1), mk, iseedk(1), iseedk(2), iseedk(3), ncalls);

for i=1:bk
	iseed=iseedk;
    fprintf(log_test,'\tStart SPLI: ((S1,S2), tau, WT - EPSILON, SE_WT, mk, iseed, ncalls) = ((%d, %d), %f, %f, %f, %d, (%d, %d, %d), %d)\n',xnew(1), xnew(2), xnewfn, xnewconstraint(1), xnewConstraintCov(1), mk, iseed(1), iseed(2), iseed(3), ncalls);
	[SPLIncalls, xold, xoldfn, xoldFnVar, xoldconstraint, ...
        xoldConstraintCov, iseed] = SPLI(problem, param, xnew, xnewfn, ...
        xnewFnVar, xnewconstraint, xnewConstraintCov, mk, iseed, delta);
	fprintf(log_test,'\tEnd SPLI: ((S1,S2), tau, WT - EPSILON, SE_WT, ncalls, SPLIncalls) = ((%d, %d),%f,%f,%f, %d, %d)\n',xold(1), xold(2), xoldfn, xoldconstraint(1), xoldConstraintCov(1), ncalls, SPLIncalls);
    iseed=iseedk;
    fprintf(log_test,'\tStart NE: ((S1,S2), tau, WT - EPSILON, SE_WT, mk, iseed, ncalls) = ((%d, %d), %f, %f, %f, %d, (%d, %d, %d), %d)\n',xold(1), xold(2), xoldfn, xoldconstraint(1), xoldConstraintCov(1), mk, iseed(1), iseed(2), iseed(3), ncalls);
	disp(['xold:' num2str(xold(1)) ',' num2str(xold(2)) ',SPLIncalls=' num2str(SPLIncalls)  ])
    
    [NEncalls, xnew, xnewfn, xnewFnVar, xnewconstraint, ...
        xnewConstraintCov, iseed, Nflag, Nx, Nfn, NFnVar, Nconstraint, ...
        NConstraintCov, Nphat] = NE(problem, param, xold, xoldfn, ...
        xoldFnVar, xoldconstraint, xoldConstraintCov, mk, iseed, delta);
    fprintf(log_test,'\tEnd NE: ((S1,S2), tau, WT - EPSILON, SE_WT, ncalls, NEncalls) = ((%d, %d),%f,%f,%f, %d, %d)\n',xnew(1), xnew(2), xnewfn, xnewconstraint(1), xnewConstraintCov(1), ncalls, NEncalls);
    
    disp(['xnew:' num2str(xnew(1)) ',' num2str(xnew(2)) ',NEncalls=' num2str(NEncalls)  ])
    ncalls = ncalls + SPLIncalls + NEncalls;
    
    disp(['ncalls:' num2str(ncalls)  ])
    
    if  xoldfn==xnewfn
		%SPLINE ended since NE and SPLI returned the same sol
        fprintf(log_test,'\tEnd SPLINE: ((S1,S2), tau, WT - EPSILON, SE_WT, ncalls) = ((%d, %d),%f,%f,%f, %d)\n',xnew(1), xnew(2), xnewfn, xnewconstraint(1), xnewConstraintCov(1), ncalls);
		break
    end
end    
	
%the starting sol is better than the new solution by a very small margin
if x0fn + eps(x0fn) <= xnewfn %BG Modified: 0.00005 in previous 
	xnew=x0;
	xnewfn=x0fn;
    xnewFnVar=x0FnVar;
    xnewconstraint=x0constraint;
    xnewConstraintCov=x0ConstraintCov;
end
end


function [ncalls, xnew, xnewfn, xnewFnVar, xnewconstraint, ...
    xnewConstraintCov, iseed, Nflag, Nx, Nfn, NFnVar, Nconstraint, ...
    NConstraintCov, Nphat] = NE(problem, param, x, fn, FnVar, ...
    constraint, ConstraintCov, mk, iseed, delta)
global AirportSecurityFlag
global mobs
id = int32(param(2));
nseeds = int32(param(3));
nsecMeas = int32(param(4));
iseedk = iseed;
xold=x;

xnew=x;
xnewfn=fn;
xnewFnVar=FnVar;
xnewconstraint=constraint;
xnewConstraintCov=ConstraintCov;

ncalls=0;

y2=fn;
ixquad=zeros(1,id);

Nflag=zeros(2*id, 1);
Nx=zeros(2*id, id);
Nfn=zeros(2*id, 1);
NFnVar=zeros(2*id, 1);
Nconstraint=zeros(2*id, nsecMeas);
NConstraintCov=zeros(2*id, nsecMeas); 
Nphat=zeros(2*id, 1);

for i=1:id
	count=1;

    xold(i)=xold(i)+1;
    iseed=iseedk;
	[Dummy, flag2, xoldfn, xoldFnVar, Dummy, Dummy, xoldconstraint, ...
        xoldConstraintCov, Dummy, Dummy, iseed] = oracle(str2func(problem), ...
        param, xold, mk, iseed);
    if sum(xoldconstraint > sqrt(mk*xoldConstraintCov)/mk^delta)>0
        flag2=1;
    end
    Nx(2*i-1,:)=xold;
    Nflag(2*i-1)=flag2;
    Nfn(2*i-1)=xoldfn;
    NFnVar(2*i-1)=xoldFnVar;
    Nconstraint(2*i-1, :)=xoldconstraint;
    NConstraintCov(2*i-1, :)=xoldConstraintCov;  
    Nphat(2*i-1)=tcdf(mk^(0.5-delta)-xoldconstraint/...
        sqrt(xoldConstraintCov), mk-1);
    
    if flag2 == 0
        if AirportSecurityFlag == 1
            ncalls = ncalls + mobs; %mobs: Number of observations generated
        else
            ncalls = ncalls + mk;
        end
		y1=xoldfn; 
		count=count+1;
        if xoldfn + eps(xoldfn) < xnewfn %BG Modified: 0.00005 in previous 
			xnew=xold;
			xnewfn=xoldfn;
			xnewFnVar=xoldFnVar;
            xnewconstraint=xoldconstraint;
            xnewConstraintCov=xoldConstraintCov;
            PUSH(xnew);
        end
    end

	xold(i)=xold(i)-2;
	iseed=iseedk;
	[Dummy, flag2, xoldfn, xoldFnVar, Dummy, Dummy, xoldconstraint, ...
        xoldConstraintCov, Dummy, Dummy, iseed] = oracle(str2func(problem), ...
        param, xold, mk, iseed);
    if sum(xoldconstraint > sqrt(mk*xoldConstraintCov)/mk^delta)>0
        flag2=1;
    end
    Nx(2*i,:)=xold;
    Nflag(2*i)=flag2;
    Nfn(2*i)=xoldfn;
    NFnVar(2*i)=xoldFnVar;
    Nflag(2*i)=flag2;
    Nconstraint(2*i, :)=xoldconstraint;
    NConstraintCov(2*i, :)=xoldConstraintCov;  
    Nphat(2*i)=tcdf(mk^(0.5-delta)-xoldconstraint/...
        sqrt(xoldConstraintCov), mk-1);

    if flag2 == 0
		if AirportSecurityFlag == 1
            ncalls = ncalls + mobs; %mobs: Number of observations generated
        else
            ncalls = ncalls + mk;
        end
		y3=xoldfn; 
		count=count+1;
        if xoldfn + eps(xoldfn) < xnewfn %BG Modified: 0.00005 in previous 
			xnew=xold;
			xnewfn=xoldfn;
            xnewFnVar=xoldFnVar;
            xnewconstraint=xoldconstraint;
            xnewConstraintCov=xoldConstraintCov;
            PUSH(xnew);
        end 
    end

	xold(i)=xold(i)+1;
	xqnew=xold(i);

    % quadratic search
    if count==3 
		a = (y1+y3)/2.0 - y2;
		b = (y1-y3)/2.0;
        if a-eps(a) > 0 %BG Modified: 0.00005 in previous 
			xqnew = int32(xold(i) - (b / (a + a)));
        end
    end
    if  abs(xqnew) < 2147483646.0 %2^31-2
		ixquad(i) = xqnew;
    end
end
		
iseed=iseedk;
%call oracle at ixquad
[Dummy, flag2, ixquadfn, ixquadFnVar, Dummy, Dummy, ixquadconstraint, ...
    ixquadConstraintCov, Dummy, Dummy, iseed] = ...
    oracle(str2func(problem), param, ixquad, mk, iseed);
    if sum(ixquadconstraint > sqrt(mk*ixquadConstraintCov)/mk^delta)>0
        flag2=1;
    end
    
if flag2==0
    if AirportSecurityFlag == 1
        ncalls = ncalls + mobs; %mobs: Number of observations generated
    else
        ncalls = ncalls + mk;
    end

    if ixquadfn + eps(ixquadfn) < xnewfn %BG Modified: 0.00005 in previous 
		xnew=ixquad;
        xnewfn=ixquadfn;
        xnewFnVar=ixquadFnVar;
        xnewconstraint=ixquadconstraint;
        xnewConstraintCov=ixquadConstraintCov;
        PUSH(xnew);
    end
end
end


function [ncalls, xbest, xbestfn, xbestFnVar, xbestconstraint, ...
    xbestConstraintCov, iseed] = SPLI(problem, param, x, fn, FnVar, ...
    constraint, ConstraintCov, mk, iseed, delta)
global AirportSecurityFlag
global mobs
id = int32(param(2));
nsecMeas = int32(param(4));
imax=100;
jmax=5;
iseedk=iseed;

xbest=x;
xbestfn=fn;
xbestFnVar=FnVar;
xbestconstraint=constraint;
xbestConstraintCov=ConstraintCov;

ncalls=0;
s0=1.1;
c=1.1;
			
for j=0:jmax
   x1=PERTURB(xbest, iseed);
   iseed=iseedk;
   plixbest=xbest;
   [Dummy, gamma, npoints, plixbest, plixbestfn, plixbestFnVar, ...
       plixbestconstraint, plixbestConstraintCov, iseed] = PLI(problem, ...
       param, x1, plixbest, mk, iseed, delta);
   
    if AirportSecurityFlag == 1
        ncalls = ncalls + mobs; %mobs: Number of observations generated
    else
        ncalls = ncalls + npoints*mk;
    end
	

	% update current best
    if  plixbestfn + eps(plixbestfn) < xbestfn && npoints>0 %BG Modified: 0.00005 in previous 
        xbest=plixbest;
        xbestfn=plixbestfn;
        xbestFnVar=plixbestFnVar;
        xbestconstraint=plixbestconstraint;
        xbestConstraintCov=plixbestConstraintCov;
        PUSH(xbest);
    end	
    if npoints < id+1
        return 
    end	
	glength=norm(gamma);
    if glength + eps(glength) <= 0 %BG Modified: 0.00005 in previous 
		return
    end
    x0=xbest;
    gamma=gamma/glength;
    
    for i=0:imax
        s = s0 * c^i;
        ix1=zeros(1,id);
        for k=1:id
            ix1(k)=floor(x0(k)-s*gamma(k)+0.5);
            % UNCOMMENT THE FOLLOWING LINES 
            % IF DECISION VARIABLES ARE BINARY 0-1
            % if ix1(i)<0
            %     ix1(i)=0;
            % elseif ix1(i)>1
            %     ix1(i)=1;
            % end
        end
        iseed=iseedk;
        [Dummy, flag2, ix1fn, ix1FnVar, Dummy, Dummy, ix1constraint, ...
            ix1ConstraintCov, Dummy, Dummy, iseed] = oracle(str2func(problem), ...
            param, ix1, mk, iseed);
        if sum(ix1constraint > sqrt(mk*ix1ConstraintCov)/mk^delta)>0
            flag2=1;
        end 
        if flag2~=0
            return	%ix1 is infeasible
        end
		if AirportSecurityFlag == 1
            ncalls = ncalls + mobs; %mobs: Number of observations generated
        else
            ncalls = ncalls + mk;
        end
        if ix1fn >= xbestfn + eps(xbestfn) && i <= 2 %BG Modified: 0.00005 in previous 
            return
        end
        if ix1fn >= xbestfn + eps(xbestfn) %BG Modified: 0.00005 in previous 
            break
        end
		xbest=ix1;
		xbestfn = ix1fn;
		xbestFnVar=ix1FnVar;
        xbestconstraint=ix1constraint;
        xbestConstraintCov=ix1ConstraintCov;
        PUSH(xbest);
    end    
end
end


function [fbar, gamma, npoints, plixbest, plixbestfn, plixbestFnVar, ...
    plixbestconstraint, plixbestConstraintCov, iseed] = PLI(problem, ...
    param, x, plixbest, mk, iseed, delta)
global AirportSecurityFlag
global mobs
PLI_ncalls = 0;

id = int32(param(2));
nseeds=int32(param(3));
nsecMeas = int32(param(4));
npoints=0;
strange=3.145962987654;
gamma=zeros(1,id);
iseedk=iseed;

x0=floor(x);
z=x-x0;
z=[1,z,0];
[Dummy, p]=sort(z, 'descend');
w=zeros(1, id+1);
for i=1:id+1		
	w(i)=z(p(i))-z(p(i+1));
end	
wsum=0;
fbar=0;

%call oracle at x0
[Dummy, flag2, x0fn, x0FnVar, Dummy, Dummy, x0constraint, x0ConstraintCov, ...
    Dummy, Dummy, iseed]=oracle(str2func(problem), param, x0, mk, iseed);	
    if sum(x0constraint > sqrt(mk*x0ConstraintCov)/mk^delta)>0
        flag2=1;
    end

if flag2 == 0
    PLI_ncalls = PLI_ncalls + mobs;
    
	npoints=npoints+1;
	wsum = wsum + w(1);
	fbar = fbar + w(1)*x0fn;
	ghatold = x0fn;
    plixbest=x0;
    plixbestfn = x0fn;
    plixbestFnVar=x0FnVar;
	plixbestconstraint=x0constraint;
	plixbestConstraintCov=x0ConstraintCov;	
else
    ghatold = 0;
	plixbestfn = strange;
%     plixbestFnVar=0; %BG Modified
% 	plixbestconstraint=1; %BG Modified
% 	plixbestConstraintCov=1e-4;	 %BG Modified
end

for i=2:id+1
    x0(p(i)-1)=x0(p(i)-1)+1;
    iseed=iseedk;
    %call oracle at the other id points that form the simplex
	[Dummy, flag2, x0fn, x0FnVar, Dummy, Dummy, x0constraint, x0ConstraintCov, ...
        Dummy, Dummy, iseed]=oracle(str2func(problem), param, x0, mk, iseed);
    if sum(x0constraint > sqrt(mk*x0ConstraintCov)/mk^delta)>0
        flag2=1;
    end

    if flag2 == 0
        PLI_ncalls = PLI_ncalls + mobs;
        
		npoints=npoints+1;
		wsum = wsum + w(i);
		fbar = fbar + w(i)*x0fn;
		gamma(p(i)-1) = x0fn - ghatold;
		ghatold = x0fn;
        if plixbestfn == strange || x0fn + eps(x0fn) < plixbestfn %BG Modified: 0.00005 in previous 
            plixbest=x0;
            plixbestfn = x0fn;
            plixbestFnVar=x0FnVar;
            plixbestconstraint=x0constraint;
            plixbestConstraintCov=x0ConstraintCov;	
        else
            disp('')
        end
    end
end

if wsum > eps(wsum) %BG Modified: 0.00005 in previous 
    fbar = fbar/wsum;	
end
mobs = PLI_ncalls;
end


function xpert = PERTURB(x, iseed)

id=length(x);
seed=iseed(1);

xpert=zeros(1,id);
for i=1:id
	[seed, u] = u16807d(seed);
    xpert(i) = x(i) + .3*(u - 0.5);
    
    % UNCOMMENT THE FOLLOWING LINES 
    % IF DECISION VARIABLES ARE BINARY 0-1
    % if x(i)==0
    %     xpert(i) = double(x(i) + 0.15*u);
    % else
    %     xpert(i) = double(x(i) - 0.15*u);
    % end
    
end
end


function [ncalls, xnew, xnewfn, xnewFnVar, xnewconstraint, ...
    xnewConstraintCov, iseed] = backtrack(param, x1, x1fn, x1FnVar, x1constraint, x1ConstraintCov, ... 
    lastiseed, Nflag, ...
    Nx, Nfn, NFnVar, Nconstraint, NConstraintCov, Nphat, alphar)

% Backtrack will pick the neighbor with the smallest objective function 
% and phat>=alpha_r
% Currently function only explores the neighbors

iseed=lastiseed;
ncalls=0;
id=int32(param(2));

xnew=x1; 
xnewfn=x1fn;
xnewFnVar=x1FnVar;
xnewconstraint=x1constraint;
xnewConstraintCov=x1ConstraintCov;
for i=1:2*id
    if Nflag(i)~=1 && Nphat(i)>=alphar
        xnew=Nx(i,:);
        xnewfn=Nfn(i);
        xnewFnVar=NFnVar(i);
        xnewconstraint=Nconstraint(i, :);
        xnewConstraintCov=NConstraintCov(i, :);
        break;
    end
end
end


function PUSH(x)

id=length(x);
global stack1;
[i,Dummy]=size(stack1);
flag=1;
while i>=1
    if sum(stack1(i,:)-x==0)==id
        flag=0;
        break
    end
    i=i-1;
end
if flag==1
    stack1=[stack1; x];
end
end


function [flag1, flag2, fn, FnVar, FnGrad, FnGradCov, constraint, ...
    ConstraintCov, ConstraintGrad, ConstraintGradCov, iseed]=...
    oracle(orchandle, param, x, m, iseed)
%
% INPUT 
%       problem
%         problem name function handle
%       param
%         problem param
%           param(1): problem number
%           param(2): problem dimension
%           param(3): nseeds
%           param(4): number of stocastic constraints
%           param(5), ... : other problem specific parameters
%       x
%         decision variable
%       m 
%         sample size
%       iseed
%         vector of input seeds
%
% OUTPUT
%       flag1
%         equals 1 when parameters to oracle are incorrect, 0 otherwise
%       flag2
%         equals 1 when infeasible, 0 otherwise
%       fn
%         estimate of expected real valued objective function
%       FnVar
%         variance of expected objective function
%       FnGrad
%         vector of estimate of gradient at x
%       FnGardCov
%         covariance matrix of gradient estimator at x
%       constraint
%         vector of constraint function estimators
%       ConstraintCov
%         covariance matrix of constraint extimators at x
%       ConstraintGrad
%         matrix of gradient estimators of constraint functions at x
%       ConstraintGradCov
%         3-dimensional covariance array of gradient estimators of 
%         constraint functions at x
%
[flag1, flag2, fn, FnVar, FnGrad, FnGradCov, constraint, ConstraintCov, ...
    ConstraintGrad, ConstraintGradCov, iseed]=orchandle(param, x, m, iseed);
end


function [iseed,u16807d]=u16807d(iseed)
%
% A linear congruential pseudorandom number generator                 
% using constant 16807 and modulus (2**31)-1.                       
% iseed = iseed*16807 (mod 2^31 -1)                          
%     INPUT
%        iseed.   Integer.                                            
%                 Chosen from [1,2147483646] on the first call.    
%                 Thereafter, the value returned from the last call
%     OUTPUT
%        iseed.   Integer. To be used in the next call.                     
%        u16807d. Real. A pseudorandom number in (0,1).   

u16807d=0;
while (u16807d<=0 || u16807d>=1)
    iseed = mod (iseed * 16807,2147483647);
    u16807d = iseed / 2147483648;
end
end